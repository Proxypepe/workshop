**Prometheus** — это система мониторинга и оповещений, хранящая и обрабатывающая метрики, собираемые из экспортеров в Time Series Database (TSDB). В отличие от SQl-like СУБД, Prometheus сам собирает метрики по указанным хостам.

Для работы с метриками в Prometheus используется язык запрос PromQL. Он позволяет составлять сложные запросы и использовать математические операторы. Результат запроса может быть выведен в табличной или графической форме.

Сами данные хранятся в виде набора файлов на жестком диске сервера, где установлен Prometheus. Через конфигурационный файл Prometheus можно настроить длительность хранения данных и задать объём дискового пространства для хранения данных.

Также Prometheus может оповещать, о различных событиях, которые настраиваются администратором Prometheus в специальном конфигурационном файле alerts. Для удобной и корректной работы системы оповещения применяется специальное расширение — AlertManager.


```yaml
annotations: 
	prometheus.io/scrape: "true"
	prometheus.io/path: '/metrics' 
	prometheus.io/port: "9100"
```


1. **HTTP (HTTP Pull)**:
    
    - Протокол HTTP используется для опроса (pull) метрик от целевых приложений и сервисов.
    - Prometheus выполняет HTTP-запросы к конечным точкам (endpoints) целевых приложений, чтобы получить метрики.
    - Этот протокол позволяет Prometheus извлекать метрики из различных источников, включая веб-сервисы и приложения, поддерживающие HTTP.
2. **gRPC (gRPC Remote Write)**:
    
    - gRPC - это высокопроизводительный и мощный протокол удаленного вызова процедур, который может использоваться для отправки данных метрик от Prometheus к удаленным хранилищам данных (например, Thanos или Cortex).
    - Протокол gRPC предоставляет эффективный способ передачи данных и поддерживает потоковую передачу данных для эффективной синхронизации.
3. **Prometheus Remote Write (Remote Write)**:
    
    - Это протокол, разработанный специально для передачи данных метрик от Prometheus к удаленным хранилищам данных.
    - Он обеспечивает высокую степень сжатия данных и эффективную отправку метрик с минимальной нагрузкой на сеть.
4. **Prometheus Push Gateway (Push)**:
    
    - В случае, когда целевой объект не поддерживает HTTP-сервер для pull-запросов, Prometheus может использовать промежуточный сервер, известный как "Prometheus Push Gateway," который принимает push-запросы от объектов мониторинга и сохраняет метрики для последующего сбора Prometheus.
5. **SNMP (Simple Network Management Protocol)**:
    
    - Prometheus также поддерживает сбор метрик с устройств, поддерживающих протокол SNMP. Для этого используется экспортер SNMP, такой как SNMP Exporter.



Основные понятия
1. Метрика - Метрика – это конкретная характеристика, показывающая текущее состояние по определенному параметру (_пример: количество одновременных подключений_);
2. Параметр
3. Логирование — это **процесс формирования логов, а именно: фиксация и структурирование информации о работе системы в отдельные лог-файлы с возможностью быстрого доступа к ним в случае необходимости**.
4. Трассировка —  это **метод отслеживания и визуализации всех подзапросов из множества сервисов, которые запускаются в результате выполнения одного конкретного родительского запроса**
5. Оповещение: Это непрерывная проверка метрик или логов на соответствие пороговым значениям и вызывает действие или уведомление в случае нарушения установленного порога.
6. - Сервер мониторинга – ПО, которое выполняет агрегацию, хранение, пересчет данных по метрикам;
7. Агент мониторинга – ПО, которое выполняет сбор метрик с хоста, который подлежит мониторингу, а так же отправку данных на сервер мониторинга;
8. Визуализация: Это графическое представление метрик, логов или трейсов.
9. SLA
10. SLO
11. SLI
12. Push versus pull
13. Что мерить: Методики google, use, red

SLA (Service Level Agreement), SLO (Service Level Objective) и SLI (Service Level Indicator) - это понятия, связанные с обеспечением качества и доступности услуг в информационных технологиях и области обслуживания клиентов. Вот их объяснения:

1. **SLA (Service Level Agreement)**:
    
    - Это формальное соглашение между поставщиком услуг и клиентом, которое определяет ожидания и обязательства в отношении качества и доступности предоставляемых услуг.
    - SLA содержит конкретные числовые метрики и показатели, такие как максимальное время простоя, процент доступности и другие, которые клиент может ожидать от поставщика услуг.
    - SLA часто включает в себя штрафы или компенсации в случае нарушения обязательств.
2. **SLO (Service Level Objective)**:
    
    - Это цель или ожидание, которое определено в SLA.
    - SLO устанавливает конкретные метрики качества и доступности услуги, которые должны быть достигнуты или превзойдены для удовлетворения клиентов.
    - SLO является более конкретным и измеримым, чем SLA, и он определяет, каким образом будет оцениваться выполнение SLA.
3. **SLI (Service Level Indicator)**:
    
    - Это конкретный измеримый показатель или метрика, которая используется для оценки качества услуги.
    - SLI представляет собой данные, собираемые и анализируемые для определения того, соответствует ли услуга установленным SLO.
    - Примерами SLI могут быть процент доступности веб-сайта, среднее время ответа на запросы или другие ключевые метрики.

https://www.atlassian.com/incident-management/kpis/sla-vs-slo-vs-sli
https://www.blameless.com/blog/sla-vs-slo


**Push-стратегия мониторинга (Push Monitoring Strategy):** В этой стратегии данные активно отправляются или "пушатся" от источника данных к системе мониторинга. Это означает, что источник данных инициирует передачу информации в систему мониторинга по мере появления новых данных или событий.

**Pull-стратегия мониторинга (Pull Monitoring Strategy):** В этой стратегии система мониторинга "тянет" данные из источника по запросу. То есть, система мониторинга периодически опрашивает источники данных, чтобы получить актуальную информацию. Этот метод полезен, когда данные не поступают непрерывно, и нет необходимости в мгновенной передаче.

![[Pasted image 20230917214435.png]]


## Архитектура

![[Pasted image 20230917212627.png]]

![[Pasted image 20230919104625.png]]

1. Компоненты
2. Как работает бд

1. **Prometheus Server (Сервер Prometheus):** Это центральный компонент системы Prometheus. Он отвечает за сбор, хранение и обработку данных мониторинга. Prometheus Server выполняет следующие функции:
    
    - Сбор данных: Он периодически собирает метрики от различных целей мониторинга, таких как приложения, серверы и сервисы.
    - Хранение данных: Он сохраняет собранные данные в свой собственной временной базе данных.
    - Операции над данными: Prometheus Server позволяет выполнять различные операции над данными, включая агрегацию, фильтрацию и вычисление предупреждений.
2. **PromQL (Prometheus Query Language):** Это язык запросов, который позволяет пользователю формулировать запросы к данным, хранящимся в системе Prometheus. С помощью PromQL вы можете выполнять запросы, создавать выражения для агрегации данных и создавать правила предупреждений.
3. **Exporter (Экспортер):** Экспортеры - это дополнительные компоненты или приложения, которые позволяют собирать метрики из различных систем и приложений, которые не являются нативно совместимыми с Prometheus. Экспортеры работают как мост между Prometheus и источниками данных. Например, существуют экспортеры для сбора метрик из баз данных, веб-серверов, облачных сервисов и других систем. Эти экспортеры предоставляют HTTP-интерфейс, на который Prometheus Server может отправлять запросы для получения данных.
4. **Collector (Сборщики):** Сборщики - это компоненты, которые собирают метрики от различных источников и предоставляют их Prometheus Server. Существуют стандартные сборщики для сбора данных о системе, такие как сведения о CPU, памяти и дисках. Также можно создавать собственные сборщики для сбора данных о приложениях и сервисах.
5. **Alertmanager:** Этот компонент отвечает за управление и отправку оповещений и предупреждений на основе данных, собранных Prometheus. Alertmanager позволяет настраивать правила предупреждений и определять, какие действия следует предпринять при возникновении определенных событий.
6. **Push Gateway:** Push Gateway - это компонент, который позволяет приложениям "пушить" свои метрики в Prometheus, вместо того чтобы ожидать, пока Prometheus выполнит опрос. Это полезно, например, для приложений, которые не постоянно активны.

**Storage**

https://github.com/prometheus/prometheus/blob/release-2.47/tsdb/docs/format/README.md

Prometheus включает в себя локальную временную базу данных на диске, а также опционально интегрируется с удаленными системами хранения.

Локальное хранилище Локальная временная база данных Prometheus сохраняет данные в специальном, высокоэффективном формате на локальном носителе.

Размещение на диске Принятые выборки группируются в блоки по два часа. Каждый блок из двух часов состоит из каталога, содержащего подкаталог chunks с всеми выборками временных рядов для этого временного окна, файла метаданных и файла индекса (который индексирует имена метрик и метки временных рядов в каталоге chunks). Выборки в каталоге chunks группируются в один или более сегментных файлов размером до 512 МБ каждый по умолчанию. Когда ряды удаляются через API, записи об удалении сохраняются в отдельных файлах-могилах (вместо немедленного удаления данных из сегментов блока).

Текущий блок для входящих выборок хранится в памяти и не полностью сохраняется. Он защищен от сбоев журналом записи (WAL write-ahead log), который может быть воспроизведен при перезапуске сервера Prometheus. Файлы журнала записи предварительной записи хранятся в каталоге wal в сегментах размером 128 МБ. Эти файлы содержат необработанные данные, которые еще не были скомпонованы; поэтому они значительно больше обычных файлов блоков. Prometheus будет хранить не менее трех файлов журнала записи предварительной записи. Серверы с высокой нагрузкой могут хранить больше трех файлов WAL, чтобы сохранить как минимум два часа необработанных данных.

Каталог данных сервера Prometheus выглядит примерно так:
```
./data
├── 01BKGV7JBM69T2G1BGBGM6KB12
│   └── meta.json
├── 01BKGTZQ1SYQJTR4PB43C8PD98
│   ├── chunks
│   │   └── 000001
│   ├── tombstones
│   ├── index
│   └── meta.json
├── 01BKGTZQ1HHWHV8FBJXW1Y3W0K
│   └── meta.json
├── 01BKGV7JC0RY8A6MACW02A2PJD
│   ├── chunks
│   │   └── 000001
│   ├── tombstones
│   ├── index
│   └── meta.json
├── chunks_head
│   └── 000001
└── wal
    ├── 000000002
    └── checkpoint.00000001
        └── 00000000
```

Структура данных Prometheus на файловой системе включает в себя несколько важных компонентов и каталогов. Вот обзор структуры данных Prometheus на файловой системе:

1. **Data Directory (Директория данных)**:
    
    - Это основная директория, в которой хранятся все данные временных рядов, собранные и сохраненные Prometheus.
    - Каждый временной ряд метрики сохраняется в сжатом и оптимизированном формате внутри этой директории.
    - Файлы данных организованы в блоки по времени (обычно по два часа).
2. **Chunks Directory (Директория блоков)**:
    
    - Внутри директории данных находится поддиректория "chunks," где хранятся сегменты временных рядов.
    - Сегменты представляют собой наборы сэмплов метрик, объединенных в один или несколько файлов объемом до 512 МБ (по умолчанию).
    - Эти сегменты содержат несжатые данные, которые позже могут быть сжаты.
3. **WAL Directory (Директория журнала записи перед записью)**:
    
    - Для обеспечения надежности и сохранности данных Prometheus использует журнал записи перед записью (Write-Ahead Log, WAL).
    - Файлы журнала записи перед записью хранятся в директории "wal" и используются для восстановления данных после сбоев или перезапусков Prometheus.
    - Эти файлы содержат необработанные данные, которые еще не были сжаты.
4. **Tombstones Directory (Директория могильников)**:
    
    - При удалении временных рядов или метрик через API, записи об удалении сохраняются в отдельных файлах, называемых "могильниками" (tombstones).
    - Tombstones директория содержит эти записи об удалении, и данные не удаляются непосредственно из сегментов данных.
5. **Index Files (Файлы индексов)**:
    
    - Внутри директории каждого блока данных находятся файлы индексов, которые индексируют и обеспечивают быстрый доступ к временным рядам и метрикам.
6. **Metadata Files (Файлы метаданных)**:
    
    - Для хранения метаданных, таких как метки (labels) и имена метрик, используются файлы метаданных.
    - Эти файлы содержат информацию о временных рядах и метриках, что позволяет Prometheus эффективно идентифицировать и извлекать необходимые данные.

  
Leveldb (LevelDB) - это встраиваемая (embedded) база данных с открытым исходным кодом, разработанная Google. Она предназначена для эффективного хранения и управления данными в локальных приложениях и системах. LevelDB используется в различных контекстах, и одним из таких контекстов является его использование в Prometheus для хранения данных временных рядов метрик.

В Prometheus LevelDB выполняет следующие функции:

1. **Хранение данных временных рядов**: LevelDB используется для хранения временных рядов метрик, собираемых Prometheus. Эти временные ряды представляют собой временные данные, связанные с метриками, такими как использование CPU, память, сеть и другие параметры системы и приложений.
    
2. **Индексация и поиск данных**: LevelDB обеспечивает эффективную индексацию и поиск данных временных рядов, что позволяет Prometheus быстро извлекать необходимую информацию для запросов и агрегации.
    
3. **Сжатие данных**: Для экономии дискового пространства LevelDB поддерживает сжатие данных. Это важно, так как данные временных рядов могут быстро накапливаться, и сжатие помогает уменьшить объем хранимых данных.
    
4. **Обеспечение надежности данных**: LevelDB обеспечивает надежное сохранение данных и их восстановление после сбоев. Это важно для обеспечения целостности метрических данных в случае сбоев или перезапусков Prometheus.
    
5. **Управление журналом записи перед записью (WAL)**: LevelDB использует журнал записи перед записью (WAL) для обеспечения сохранности данных. Журнал записи перед записью содержит необработанные данные, которые могут быть восстановлены в случае сбоев.


Модель данных

  
Образцы представляют собой фактические данные временных рядов. Каждый образец состоит из следующих элементов:

- a float64 value
- a millisecond-precision timestamp

```
<metric_name>[{<label_1="value_1"}>, <label_N="value_N"}>] <datapoint_numerical_value>
```
Например, временной ряд с именем метрики `api_http_requests_total` и метками `method="POST"` и `handler="/messages"` может быть записан следующим образом:

```
api_http_requests_total{method="POST", handler="/messages"}
```

![[Pasted image 20230919104659.png]]
### Counter
**Счетчик** – монотонно возрастающее число. Может быть сброшен в ноль, например, при рестартах сервиса, который пишет метрику.

```
http_requests_total{url="/login"} 10 
http_requests_total{url="/"} 100 

http_errors{status="500", url="/"} 3 
http_errors{status="401", url="/"} 26 
http_errors{status="400", url="/login"} 11 
http_errors{status="404", url="/admin"} 298 

jobs{type="cleanup", status="completed"} 42 
jobs{type="cleanup", status="failed"} 38
```
### Gauge
**"Стрелка"** — это двунаправленный счетчик, значение которого может как увеличиваться, так и уменьшаться.
```
http_active_requests{app="web"} 5 
http_active_requests{app="internal"} 1 

memory_swap{host="test"} 0 
memory_swap{host="prod"} 102400 
memory_usage_bytes{host="test"} 1295007744 
memory_usage_bytes{host="prod"} 5476434545 

disk_free_bytes{path="/var/www/"} 29298077696 
disk_free_bytes{path="/tmp/"} 37359484928
```

### Histogram

**Гистограмма** — агрегация чего-то самим приложением, когда нам интересно знать **распределение** величин по **заранее определенным** группам (buckets). Гистограмма считает **количество попаданий** в какую-то группу, то есть запоминает счетчики, а не сами значения.


```
http_duration_bucket{url="/", le="0.1"} 100 
http_duration_bucket{url="/", le="1"} 130 
http_duration_bucket{url="/", le="5"} 140 
http_duration_bucket{url="/", le="+Inf"} 141 

http_duration_sum{url="/"} 152.7625769 # это бонусом идет сумма всех значений, которые мы записали 
http_duration_count{url="/"} 141 # это количество значений, т.е. counter который всегда делает +1 на каждое обновление гистограммы
```

### Summary

Сводка — работает как гистограмма, но также рассчитывает квантили. В общем, это способ **сжать** историю наблюдений до одного числа, при этом по пути **потерять неудобные** для нас данные, чтобы не мешали смотреть на общую картину.
```
http_duration_summary{quantile="1"} 100 
http_duration_summary{quantile="0.99"} 4.300226799 http_duration_summary{quantile="0.95"} 2.204090024 http_duration_summary{quantile="0.5"} 0.073790038 
http_duration_summary{quantile="0.1"} 0.018127115 
http_duration_summary_sum 152.7625769 # как у гистограммы, сумма всех значений http_duration_summary_count 141 # и количество значений
```


Квантиль - это значение, которое разделяет упорядоченный набор данных на две части так, что определенная доля данных находится с одной стороны квантиля, а остальная часть - с другой. Например, медиана - это 50-й процентиль, которая разделяет данные на две равные части. Рассчитать квантиль можно следующим образом:

1. **Упорядочьте данные:** Сначала упорядочьте набор данных в порядке возрастания или убывания, в зависимости от вашей задачи.
    
2. **Выберите процентиль:** Определите, какой процент данных вы хотите оценить. Например, если вам нужен 25-й процентиль (квартиль), это означает, что 25% данных будут меньше или равны этому значению.
    
3. **Найдите позицию:** Вычислите позицию, на которой находится нужный процентиль в упорядоченных данных. Это делается с помощью следующей формулы:

    `Position = (P / 100) * (N + 1)`
    
    Где `P` - это процентиль (например, 25 для 25-го процентиля), `N` - общее количество данных.
    
4. **Найдите значение квантиля:** Найдите значение данных в позиции, рассчитанной на предыдущем шаге. Если позиция - целое число, то это значение квантиля. Если позиция дробная, то вычислите среднее между ближайшими значениями в позиции вверх и вниз.
    

Пример: Предположим, у вас есть следующий набор данных (упорядоченный):

`[10, 15, 20, 25, 30, 35, 40, 45, 50, 55]`

Вы хотите найти 25-й процентиль (квартиль).

1. Поскольку у вас есть 10 значений, `N = 10`.
2. Вычисляем позицию: `Position = (25 / 100) * (10 + 1) = 2.5`.
3. Значение в позиции 2.5 - это среднее между вторым и третьим значениями: `(15 + 20) / 2 = 17.5`.

Таким образом, 25-й процентиль этого набора данных равен 17.5.

Процентиль - это статистическая мера, используемая для определения значения в наборе данных, которое разделяет данные на две части так, что определенная доля данных находится с одной стороны процентиля, а остальная часть - с другой. Процентили представляют собой способ анализа распределения данных и вычисления значений, которые находятся выше или ниже заданного процентного порога.

Процентили широко используются в статистике и анализе данных, особенно при работе с большими объемами данных, чтобы получить представление о том, как данные распределены и какие значения можно считать "высокими" или "низкими" в контексте всего набора данных. Некоторые наиболее часто используемые процентили включают в себя следующие:

1. **Медиана (50-й процентиль):** Медиана разделяет данные на две равные части. 50% данных находятся выше медианы, и 50% данных находятся ниже.
    
2. **Квартили (25-й и 75-й процентили):** Первый квартиль (25-й процентиль) разделяет данные так, что 25% данных находятся ниже него, а 75% - выше. Третий квартиль (75-й процентиль) разделяет данные так, что 75% данных находятся ниже него, а 25% - выше.
    
3. **Децили (10-й, 20-й, 30-й и так далее):** Децили разделяют данные на десятки. Например, 10-й процентиль разделяет данные так, что 10% данных находятся ниже него, и так далее.
    

Процентили полезны для выявления выбросов (аномальных значений) в данных, для оценки центральной тенденции и разброса данных, а также для сравнения значений в разных частях распределения данных.

Для выявления выбросов на основе сводки (Summary) или других данных мониторинга, таких как гистограммы или временные ряды, можно использовать различные статистические методы. Один из таких методов - это использование интерквартильного размаха (Interquartile Range, IQR) и заметных выбросов (Outliers). Вот алгоритм выявления выбросов на примере сводки:

1. **Собрать данные:** Сначала соберите данные из сводки, включая значения, квантили (например, первый квартиль - Q1 и третий квартиль - Q3) и общее количество наблюдений (N).
    
2. **Вычислить интерквартильный размах (IQR):** IQR вычисляется как разница между третьим и первым квартилями: IQR = Q3 - Q1.
    
3. **Определить верхний и нижний порог для выбросов:** Вычислите верхний и нижний порог для выбросов, используя IQR. Обычно устанавливают нижний порог как Q1 - 1.5 * IQR и верхний порог как Q3 + 1.5 * IQR. Эти пороги могут быть настроены в зависимости от требований.
    
4. **Проверить значения:** Для каждого значения в данных проверьте, находится ли оно за пределами установленных порогов. Если значение меньше нижнего порога или больше верхнего порога, оно считается выбросом.
    
5. **Идентифицировать и обработать выбросы:** Все значения, которые были определены как выбросы, могут быть идентифицированы и обработаны в соответствии с требованиями вашей системы. Например, вы можете создать предупреждения или уведомления о выбросах, сохранить их для последующего анализа или принять другие меры в зависимости от контекста.
    

Этот алгоритм позволяет выявлять значения, которые находятся далеко от центральной тенденции данных и могут считаться потенциальными выбросами. Однако важно помнить, что определение выбросов и настройка порогов может зависеть от конкретного случая и требований вашего мониторинга.


## Конфигурирование

https://prometheus.io/docs/prometheus/latest/configuration/configuration/
### Глобальное

```yaml
global: 
	scrape_interval: 1m 
	scrape_timeout: 10s 
	evaluation_interval: 1m 
	external_labels: 
		dc: dc1 
		prom: prom1
```


scrape конфигурация

```yaml
scrape_configs:
- job_name: 'prometheus' 
    scrape_interval: 15s 
	scrape_timeout: 5s 
	sample_limit: 1000 
	static_configs: 
		- targets: ['localhost:9090']
	metric_relabel_configs: 
		- source_labels: [ __name__ ] 
		  regex: expensive_metric_.+ 
		  action: drop
```


![[tempsnip.png]]
1. Prometheus читает секцию конфига `scrape_configs`, согласно которой настраивает свой внутренний механизм обнаружения сервисов _(Service Discovery)_.
2. Механизм _Service Discovery_ взаимодействует с Kubernetes API (в основном для получения _endpoints_).
3. На основании данных из Kubernetes механизм _Service Discovery_ обновляет _Targets_ (список целей).

Таким образом, Prometheus сам отслеживает:  
  
- добавление и удаление **подов** (при добавлении/удалении подов Kubernetes изменяет endpoints, а Prometheus это видит и добавляет/удаляет цели);
- добавление и удаление **сервисов** (точнее, endpoints) в указанных пространствах имён _(namespaces)_.

### `<kubernetes_sd_config>`

Конфигурации службы обнаружения Kubernetes (Kubernetes SD) позволяют извлекать цели сбора данных из REST API Kubernetes и всегда оставаться синхронизированными с состоянием кластера.

### `<consul_sd_config>`

Конфигурации службы обнаружения (Service Discovery, SD) позволяют извлекать цели сбора данных из API каталога Consul.

### `<docker_sd_config>`

Конфигурации службы обнаружения Docker (Docker SD) позволяют извлекать цели сбора данных с хостов Docker Engine. Эта служба обнаружения обнаруживает "контейнеры" и создает цель для каждого сетевого IP-адреса и порта, настроенного для экспонирования контейнером.

### `<dockerswarm_sd_config>`

Конфигурации службы обнаружения Docker Swarm (Docker Swarm SD) позволяют извлекать цели сбора данных с движка Docker Swarm.

### `<dns_sd_config>`

Конфигурация обнаружения службы на основе DNS позволяет указать набор DNS-доменных имен, которые периодически опрашиваются для обнаружения списка целей. DNS-серверы, с которыми будет установлена связь, считываются из файла /etc/resolv.conf.

Этот метод обнаружения службы поддерживает только основные запросы DNS A, AAAA, MX и SRV, но не поддерживает более продвинутый подход DNS-SD, указанный в RFC6763.

### `<file_sd_config>`

Служба обнаружения на основе файлов предоставляет более универсальный способ настройки статических целей и служит интерфейсом для подключения пользовательских механизмов обнаружения служб.

Она считывает набор файлов, содержащих список нуля или более <static_config>. Изменения во всех определенных файлах обнаруживаются с помощью мониторинга диска и применяются немедленно. Файлы могут быть предоставлены в формате YAML или JSON. Применяются только изменения, приводящие к созданию правильных групп целей.

Файлы должны содержать список статических конфигураций в таких форматах: 
json 
```json
[
  {
    "targets": [ "<host>", ... ],
    "labels": {
      "<labelname>": "<labelvalue>", ...
    }
  },
  ...
]
```

yaml
```yaml
- targets:
  [ - '<host>' ]
  labels:
    [ <labelname>: <labelvalue> ... ]
```
### `<http_sd_config>`

Служба обнаружения на основе HTTP предоставляет более универсальный способ настройки статических целей и служит интерфейсом для подключения пользовательских механизмов обнаружения служб.

Она получает цели из конечной точки HTTP, содержащей список нуля или более <static_config>. Цель должна отвечать HTTP-ответом 200. Заголовок HTTP Content-Type должен быть application/json, а тело должно быть допустимым JSON.

```json

[
  {
    "targets": [ "<host>", ... ],
    "labels": {
      "<labelname>": "<labelvalue>", ...
    }
  },
  ...
]
```


PushGateway

Использование Pushgateway рекомендуется только в определенных ограниченных случаях. Существует несколько недостатков при слепом использовании Pushgateway вместо обычной модели опроса Prometheus для общего сбора метрик:

1. **Одна точка отказа и узкое место:** Когда вы мониторите несколько экземпляров через один Pushgateway, Pushgateway становится как одной точкой отказа, так и потенциальным узким местом. Если Pushgateway не работает, вы можете потерять данные. Кроме того, Pushgateway может оказаться недостаточно производительным для обработки большого количества данных.
    
2. **Потеря мониторинга состояния экземпляров:** Вы теряете автоматический мониторинг состояния экземпляров Prometheus с помощью метрики up (генерируемой при каждом сборе).
    
3. **Хранение метрик вечно:** Pushgateway никогда не забывает серии метрик, отправленных в него, и будет предоставлять к ним доступ в Prometheus бесконечно, пока эти серии метрик не будут вручную удалены через API Pushgateway. 

Это особенно важно, если несколько экземпляров задачи различают свои метрики в Pushgateway с помощью метки экземпляра или подобных механизмов. Метрики для экземпляра будут оставаться в Pushgateway даже в том случае, если исходный экземпляр будет переименован или удален.

По обычным сценариям, единственным допустимым случаем использования Pushgateway является запись результата пакетной задачи на уровне службы. Пакетная задача на уровне службы - это задача, которая не имеет семантической связи с конкретной машиной или экземпляром задачи (например, задача пакетной обработки, которая удаляет несколько пользователей для всей службы). Метрики такой задачи не должны включать метку машины или экземпляра, чтобы отделить жизненный цикл конкретных машин или экземпляров от отправленных метрик. Это уменьшает сложность управления устаревшими метриками в Pushgateway.


PromQL

## Типы Prometheus metrics

1. Строка (String)
2. Скаляр (Scalar)
3. Мгновенный вектор (Instant vector)
4. Диапазонный вектор (Range vector)

Первые два типа легко понять: строка - это просто текстовый формат, а скаляр - это числовое значение. Однако мгновенный вектор и диапазонный вектор немного сложнее.

Мгновенный вектор (Instant vector) - это набор метрик, которые имеют одинаковое время сбора. Другими словами, это срез данных, полученных в определенный момент времени. Мгновенный вектор представляет собой множество метрик, каждая из которых имеет свое значение и метки (labels), но все они собраны в один и тот же момент времени.

```
http_requests_total{host="10.2.0.4", path="/api"}
```

|name|host|path|status_code|value|
|---|---|---|---|---|
|`http_requests_total`|`10.2.0.4`|`/api`|`200`|`98`|
|`http_requests_total`|`10.2.0.4`|`/api`|`503`|`20`|
|`http_requests_total`|`10.2.0.4`|`/api`|`401`|`1`|

Cамое раннее значение для каждого потока на указанный в запросе момент времени. Поскольку семплы берутся в случайное время, Prometheus округляет результаты. Если длительность не указана, то возвращается последнее доступное значение.

![[Pasted image 20230920112546.png]]

Диапазонный вектор (Range vector) - это набор метрик, собранных в течение определенного временного диапазона. Этот тип вектора предоставляет данные за определенный интервал времени и может использоваться для анализа изменений метрик в течение этого интервала. Диапазонный вектор представляет собой набор мгновенных векторов, каждый из которых представляет собой срез данных за определенный момент времени внутри заданного интервала.

Чтобы получить значение метрики в пределах указанного отрезка времени, необходимо указать его в скобках:

```
http_requests_total{host="10.2.0.4", path="/api"}[10m]
```


|name|host|path|status_code|value|
|---|---|---|---|---|
|`http_requests_total`|`10.2.0.4`|`/api`|`200`|`641309@1614690905.515`<br><br>`641314@1614690965.515`<br><br>`641319@1614691025.502`|
|`http_requests_total`|`10.2.0.5`|`/api`|`200`|`641319@1614690936.628`<br><br>`641324@1614690996.628`<br><br>`641329@1614691056.628`|
|`http_requests_total`|`10.2.0.2`|`/api`|`401`|`368736@1614690901.371`<br><br>`368737@1614690961.372`<br><br>`368738@1614691021.372`|

Запрос возвращает несколько значений для каждого временного ряда потому, что мы запросили данные за определенный период времени, а каждое значение связано с отметкой времени.
Это называется **range vector** — все значения для каждой серии в пределах указанного временного интервала.

![[Pasted image 20230920112712.png]]


Как фильтровать данные с помощью PromQL PromQL предоставляет несколько способов фильтрации данных. В этом разделе мы подробно рассмотрим следующие возможности:

1. Метки (Labels)
2. Оператор диапазона (Range operator)
3. Смещение (Offset)
4. Модификатор @ (@ modifier)

Фильтрация данных с помощью меток в PromQL Мы видели, что данные Prometheus имеют метки, которые позволяют нам фильтровать метрики, которые мы сохраняем. Вот обзор операторов сопоставления меток:

1. = : Выберите метки, которые точно соответствуют предоставленной строке.
2. != : Выберите метки, которые не равны предоставленной строке.
3. =~ : Выберите метки, которые соответствуют регулярному выражению, предоставленному в строке.
4. !~ : Выберите метки, которые не соответствуют регулярному выражению, предоставленному в строке.

Важно: вам нужно указать имя или оператор метки. Вы не можете использовать пустую строку.

НЕТ: http_request_total {path=””}

НЕТ: http_reques_total{path=~”.*”}

ДА: http_request_total[path=~”.+”]

Фильтрация данных с помощью оператора диапазона в PromQL С помощью оператора диапазона вы можете указать временной интервал, который будет фильтровать векторы между текущим временем и определенным моментом времени.

единица времени

Продолжительность времени указывается как число, сразу за которым следует одна из следующих единиц:

ms - миллисекунды

s - секунды

m - минуты

h - часы

d - дни - предполагается, что день всегда состоит из 24 часов

w - недели - предполагается, что неделя всегда состоит из 7 дней

y - годы - предполагается, что год всегда состоит из 365 дней

Фильтрация данных с помощью смещения в PromQL С помощью смещения вы можете запросить значение за определенный период времени до момента выполнения запроса.

http_requests_total offset 5m

Фильтрация данных с помощью модификатора @ в PromQL

Модификатор @ позволяет изменить дату оценки для конкретного момента времени. Без этого модификатора по умолчанию используется текущий момент времени.

Вы можете комбинировать селекторы диапазона и смещения с модификатором @. Вот несколько примеров:

rate(http_requests_total[5m] @ 1609746000)

смещение после @

http_requests_total @ 1609746000 offset 5m

смещение перед @

http_requests_total offset 5m @ 1609746000

Операторы в PromQL В PromQL существует 3 типа операторов:

1. **Агрегирующие операторы.** Они используют только мгновенные векторы в качестве входных данных и возвращают мгновенные векторы как результат оператора. Некоторые типы агрегирующих операторов включают: Sum (Сумма), min (Минимум), max (Максимум), stddev (Стандартное отклонение), stdvar (Дисперсия), quantile (Квантиль).
    
    Агрегация (<мгновенный вектор>) => <мгновенный вектор>
    
2. **Бинарные операторы.** К ним относятся:
    
    - Арифметические операторы: +, -, /, *, ^, %;
    - Операторы сравнения: !=, =, < и другие;
    - Логические операторы: And (И), Or (Или), Unless (Исключая).
3. **Функции.** Существует множество функций, которые вы можете использовать, такие как: abs() (Абсолютное значение), changes() (Количество изменений), sort() (Сортировка), vector() (Преобразование вектора), rate() (Скорость) и многие другие. Функции принимают на вход диапазонный вектор и возвращают мгновенный вектор. Функция rate() умна и способна определить, было ли значение счетчика сброшено (например, после сбоя).

Функции помогают избежать необходимости использовать слишком много операторов при выполнении запросов. В PromQL доступны следующие функции:

|**Function**|**Description**|
|---|---|
|**count()**|Возвращает количество общих временных рядов.|
|**vector()**|Возвращает скаляр как вектор без меток.|
|**rate()**|Вычисляет среднюю скорость увеличения временных рядов в диапазоне вектора.|
|**increase()**|Увеличивает указанные временные ряды в диапазоне вектора.|
|**time()**|Возвращает количество секунд с 1 января 1970 года по UTC.|
|**delta()**|Возвращает разницу между первым и последним значением каждого элемента временного ряда.|
|**<aggr>_over_time()**|Агрегирует каждую серию из заданного диапазона вектора и возвращает мгновенный вектор с результатами агрегации по сериям, используется с функциями `sum`, `avg`, `min`, `max` и другими.Агрегирует каждую серию из заданного диапазона вектора и возвращает мгновенный вектор с результатами агрегации по сериям, используется с функциями `sum`, `avg`, `min`, `max` и другими.|

node exporter

```
https://github.com/prometheus/node_exporter
```

Node Exporter - это компонент системы мониторинга Prometheus, который предназначен для сбора и предоставления метрик о состоянии операционной системы и аппаратного обеспечения на уровне хоста. По умолчанию node exporter работает на порте 9100.

```yaml
hostPID: true 
hostIPC: true 
hostNetwork: true
```

```
volumeMounts: 
- name: sys 
  mountPath: /host/sys 
  mountPropagation: HostToContainer 
- name: root 
  mountPath: /root 
  mountPropagation: HostToContainer
```

```
volumes: 
- name: sys 
  hostPath: 
    path: /sys 
- name: root 
  hostPath: 
    path: /
```

Prometheus Node Exporter предоставляет метрики уровня аппаратного обеспечения и операционной системы, которые предоставляются ядрам *NIX через метрические сборщики. Node Exporter измеряет множество метрик, таких как:



|**Memory**|RAM total, RAM Used, RAM Cache, RAM Free|
|---|---|
|**Disk**|Disk Space, IOPS, Mounts|
|**CPU**|CPU Load, CPU Memory Disk|
|**Network**|Network traffic, TCP flow, Connections|

**Сборщики по умолчанию и опциональные**
Сборщик (collector) - это часть экспортера. Это, по сути, код, написанный для сбора данных метрики. Примером метрики может быть "Использование ядра процессора" или набор метрик. Таким образом, сборщики также представляют собой метрику или набор метрик. Следующая диаграмма показывает их отношение к узлам, Prometheus Node Exporter и Prometheus:


![[Pasted image 20230920122811.png]]

Как включить сборщики: Дополнительные сборщики могут быть включены путем добавления флага "--collector.<name>" в раздел "args" манифеста DaemonSet при развертывании. Сборщики, включенные по умолчанию, могут быть отключены с помощью флага "--no-collector.<name>". Мы рекомендуем тщательно тестировать любые новые включенные сборщики перед их выпуском в производство.

Один из способов - это мониторинг метрики "scrape_duration_seconds" и метрики "scrape_samples_post_metric_relabling", чтобы убедиться, что сбор метрик проходит успешно и проверить любые изменения в кардинальности.

Как отключить сборщики: Для отключения всех сборщиков по умолчанию используйте флаг "--collector.disable-defaults" совместно с флагами для всех сборщиков, которые вы хотите использовать.

Сборщик TextFile: Сборщик TextFile собирает метрики из текстовых файлов и сохраняет их в Prometheus. Он предназначен для пакетных задач или короткоживущих задач, которые не непрерывно предоставляют метрики.

Для использования сборщика TextFile добавьте флаг "--collector.textfile.directory", и сборщик будет анализировать все файлы с расширением *.prom в указанной директории в текстовом формате.


### Кратко об AlertManager

**AlertManager** — это программа, которая получает алерты от Prometheus, обрабатывает их и формирует оповещения об инцидентах. AlertManager так же как и node exporter и Prometheus устанавливает отдельно из репозитория. Настраивается AlertManager через собственный конфигурационный файл, написанный в yml-формате.

С помощью AlertManager можно гибко настраивать условия и каналы оповещения об инцидентах. Например, можно настроить уведомления на почту или в Telegram. Устанавливается AlertManager так же как и node exporter или Prometheus из официального репозитория разработчиков с помощью wget или git clone.

Основное
Какие протоколы использует и API

4. Как работает интеграция с kuber
6. rules
8. alerting

10. Как у нас реализовано


