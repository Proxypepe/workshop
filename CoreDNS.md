---
tags:
  - coreDNS
  - kubernetes
---

## Tutorial
https://coredns.io/2017/07/24/quick-start/


https://coredns.io/manual/toc/#what-is-coredns
https://kubernetes.io/docs/tasks/administer-cluster/coredns/
https://waytoeasylearn.com/learn/core-dns-in-kubernetes/


## Страничка




CoreDNS - это программное обеспечение DNS-сервера, которое часто используется для поддержки функции обнаружения служб в контейнерных средах, особенно в средах, управляемых Kubernetes. Оно было создано Миком Гибеном (Miek Gieben) в 2016 году. Ранее он уже разрабатывал DNS-сервер под названием SkyDNS и популярную библиотеку функций DNS на языке Go, называемую Go DNS. SkyDNS, как и его преемник CoreDNS, использовался в основном для поддержки обнаружения служб.

Однако Мик Гибен вдохновился архитектурой веб-сервера на языке Go под названием Caddy и решил создать CoreDNS, форкнув Caddy. CoreDNS таким образом унаследовал основные преимущества Caddy: простой синтаксис конфигурации, мощную архитектуру на основе плагинов и основу на языке Go.

Основные характеристики CoreDNS, такие как его гибкая настройка, расширяемость через плагины и надежность, делают его идеальным выбором для обеспечения DNS-сервисов в контейнерных и микросервисных средах, включая среды, управляемые Kubernetes. CoreDNS играет важную роль в обеспечении надежного и гибкого разрешения DNS-имен в таких современных сетевых сценариях.

На данный момент у CoreDNS есть несколько существенных ограничений, и оно не будет подходить для каждого возможного DNS-сервера. Главным из них является то, что CoreDNS, по крайней мере, в последней версии на момент написания этого сообщения, не поддерживает полную рекурсию. Иными словами, CoreDNS не может обработать запрос, начиная с корня пространства имен DNS, запрашивая корневой DNS-сервер и следуя по перенаправлениям до получения ответа от одного из авторитетных DNS-серверов. Вместо этого он полагается на другие DNS-серверы, обычно называемые пересыльщиками (forwarders).


| |CoreDNS|BIND|
|---|---|---|
|Full recursion|No|Yes|
|Dynamic updates|No|Yes|
|Integration with Kubernetes|Yes|No|
|Integration with Amazon Route 53|Yes|No|
|Domain Name System Security Extensions (DNSSEC) support|Limited|Full|
|Support for DNS over Transport Layer Security (DoT)|Yes|No|


# Corefile Syntax

Базовые файлы состоят из одной или нескольких записей (_entries_), которые сами содержат метки (_labels_) и определения (_definitions_).

```Corefile
label {
    definition
}
```

Иногда запись начинается с нескольких меток, и в этом случае метки могут быть разделены пробелами.

```Corefile
label1 label2 {
    definition
}
```
Если список меток настолько длинный, что занимает несколько строк, последняя метка во всех строках, кроме последней, должна заканчиваться запятой.
```Corefile
label1, label2,
label3, label4,
label5 {
    definition
}
```
Определения состоят из директив и необязательных аргументов. Каждая строка определения начинается с директивы, за которой следует ноль или более аргументов.
```Corefile
label {
    directive1 arg1 arg2
    directive2 {
        arg3
        arg4
    }
}
```
## Environment Variables
Базовые файлы также могут содержать ссылки на переменные среды, которые расширяются до своих значений и становятся метками, директивами или аргументами или их частями. Имя переменной окружения должно быть заключено в фигурные скобки.

```Corefile
label_{$ENV_VAR_1} {
    directive {$ENV_VAR_2}
}
```
Если вы собираетесь повторно использовать раздел конфигурации в Corefile несколько раз, вы можете определить его как многократно используемый фрагмент, указав имя фрагмента в круглых скобках и заключив сам фрагмент в фигурные скобки.

```
(snippet1) {
    label1 {
        directive1 arg1
        directive2 arg2 arg3
    }
}
```

Затем, чтобы вставить фрагмент в другую часть Corefile, вы используете директиву импорта с именем фрагмента (без скобок), как показано здесь:

```
import snippet1
import common.conf
import config/*.conf
```
## Server Blocks
Для CoreDNS наиболее распространенная запись называется серверным блоком. Блок сервера определяет сервер в CoreDNS — конфигурации, которая определяет, как обрабатываются запросы к конкретным доменным именам, полученные через определенные порты и по определенным протоколам. В простейшей форме метка блока сервера — это просто доменное имя домена, соответствующего некоторому набору запросов.

```
foo.example {
    # directives ...
}
```

По умолчанию CoreDNS прослушивает порт 53 протокола пользовательских датаграмм (UDP) и порт 53 протокола управления передачей (TCP), стандартные порты DNS. Чтобы настроить сервер для прослушивания порта, отличного от порта по умолчанию, добавьте двоеточие (:) после метки имени домена и номера порта.

```
.:1053 {
    # directives go here
}
```

CoreDNS использует старый добрый DNS. Но CoreDNS также может использовать DNS через Transport Layer Security (TLS), также известный как DoT, и DNS через вызов удаленных процедур общего назначения (gRPC). Чтобы настроить CoreDNS для передачи DoT или DNS через gRPC для определенных доменов или определенных портов, используйте префиксы tls:// или grpc:// соответственно перед меткой имени домена.

```
tls://foo.example {
    # directives go here
}

grpc://bar.example {
    # directives go here
}
```


# Plug-ins

## Root

`Root` плагин указывает текущий рабочий каталог CoreDNS, в котором CoreDNS, среди прочего, ожидает найти файлы данных зоны.

```
. {
    root /etc/coredns/zones
}
```

## File

Плагин `File` настраивает сервер в качестве основного DNS-сервера для зоны или зон в блоке серверов или для указанного списка зон. Поскольку основной DNS-сервер загружает данные, описывающие зоны, из файлов данных зоны, файл принимает в качестве аргумента имя файла данных зоны.

```
file DBFILE [ZONES...] {
    transfer to ADDRESS...
    reload DURATION
}
```

Поддиректива `Transfer` включает «исходящую» передачу зоны (с этого DNS-сервера на вторичные DNS-серверы). Аргументами могут быть адреса IPv4, адреса IPv6, сети IPv4 или IPv6 в нотации бесклассовой междоменной маршрутизации (CIDR) или подстановочный знак *, означающий «все адреса IPv4 и IPv6». Для любых аргументов, которые являются отдельными адресами IPv4 или IPv6, CoreDNS уведомит эти DNS-серверы о любых изменениях в зоне. Вы можете использовать несколько передач из поддиректив в одной файловой директиве.

```
foo.example {
    file db.foo.example {
        transfer to 10.0.0.1
    }
}

. {
    file db.template.example bar.example baz.example {
        transfer to *
    }
}
```

## Secondary

Плагин `secondary` настраивает CoreDNS в качестве вторичного DNS-сервера для одной или нескольких зон. Указание зон работает так же, как и с файловым плагином: они либо наследуются от блока сервера, либо указываются в качестве аргументов директивы.

```
secondary [ZONES...] {
    transfer from ADDRESS
    transfer to ADDRESS
}
```

Поддиректива Transfer from указывает адрес IPv4 или IPv6 главного DNS-сервера, с которого необходимо передать эту зону. Если вы хотите, чтобы CoreDNS опробовал более одного главного DNS-сервера, вы можете использовать множественную передачу из поддиректив.

Поддиректива Transfer to работает точно так же, как и в файловом плагине, определяя, каким вторичным DNS-серверам разрешено передавать эту зону из CoreDNS.

В частности, серверы CoreDNS не хранят данные дополнительных зон в резервном файле данных зоны. Это означает, что каждый раз при перезапуске CoreDNS он должен переносить все дополнительные зоны с их главных DNS-серверов. CoreDNS также не поддерживает инкрементальную передачу зон (IXFR), поэтому эти передачи содержат все содержимое зон.

```
foo.example {
    secondary {
        transfer from 10.0.0.1
        transfer from 10.0.1.1
    }
}

. {
    secondary bar.example {
        transfer from 10.0.0.1
        transfer to *
    }
}
```

## Forward

Плагин `forward` настраивает CoreDNS на использование сервера пересылки.


```
foo.example {
    forward foo.example 10.0.0.1
}

# Пересылать все остальные запросы в общедоступный DNS Google через TLS.
. {
    forward . tls://8.8.8.8 tls://8.8.4.4
}
```

```
forward FROM TO... {
    except IGNORED_NAMES...
    force_tcp
    prefer_udp
    expire DURATION
    max_fails INTEGER
    health_check DURATION
    policy random|round_robin|sequential
    tls CERT KEY CA
    tls_servername NAME

}
```

## Cache
Плагин кэша управляет кэшированием. Каждый сервер может иметь собственную конфигурацию кэша.


```
# Кэширует данные о foo.example, полученные от 10.0.0.1, на срок до 600 с.
foo.example {
    forward . 10.0.0.1
    cache 600
}

# Кэширует данные о bar.example, полученные из 8.8.8.8 или 8.8.4.4.
. {
    forward . 8.8.8.8 8.8.4.4
    cache 3600 bar.example
}
```

```
cache [TTL] [ZONES...] {
    success CAPACITY [TTL] [MINTTL]
    denial CAPACITY [TTL] [MINTTL]
    prefetch AMOUNT [DURATION] [PERCENTAGE%]
}
```

## Errors

Плагин `errors` предписывает CoreDNS регистрировать ошибки, возникшие во время обработки запроса в блоке сервера. Ошибки отправляются на стандартный вывод.

```
foo.example {
    file db.foo.example
    errors
}

. {
    forward . 8.8.8.8 8.8.4.4
    cache 3600
    errors
}
```

## Log
Плагин `log` инструктирует CoreDNS выгружать информацию обо всех запросах (и некоторых частях ответа) в стандартный вывод

```
log [NAMES...] [FORMAT]

log [NAMES...] [FORMAT] {
    class [CLASSES...]
}
```


Обычный формат

```
{remote}:{port} - {>id} "{type} {class} {name} {proto} {size} {>do} {>bufsize}"
 {rcode} {>rflags} {rsize} {duration}
```

```
foo.example {
    file db.foo.example
    errors
    log {
        class success denial
    }
}

bar.example {
    file db.bar.example
    errors
    log
}

# Log clients who do lookups in the defunct baz.example domain
. {
    forward . 8.8.8.8 8.8.4.4
    errors
    log baz.example "Client: {remote}, query name: {name}"
}
```


# Sample DNS Server Configurations

## Caching-Only DNS Server

DNS-серверы, предназначенные только для кэширования, могут искать любое доменное имя, но не являются авторитетными для каких-либо зон. Они полезны на загруженных серверах, поскольку обеспечивают локальный кеш часто просматриваемых записей ресурсов.

Конфигурация DNS-сервера, предназначенного только для кэширования, довольно проста: мы используем одну запись для корня с подключаемым модулем пересылки, чтобы сообщить CoreDNS, какие серверы пересылки использовать (поскольку он еще не может выполнять рекурсию сам по себе), и подключаемый модуль кэширования. -in, чтобы указать CoreDNS кэшировать полученные ответы. Мы также используем плагины ошибок и журналов, которые помогут нам диагностировать проблемы позже.

```
. {
    forward . 8.8.8.8 8.8.4.4
    cache
    errors
    log
}
```

## Primary DNS Server

Вы можете использовать простой основной DNS-сервер для размещения одной или нескольких зон. Файл Corefile для основного DNS-сервера немного сложнее, чем для DNS-сервера, предназначенного только для кэширования, но ненамного. Мы будем использовать запись для foo.example, зоны, для которой этот DNS-сервер будет основным, с корневым плагином, чтобы указать CoreDNS, в какой каталог мы поместим файлы данных нашей зоны. (Если мы этого не сделали, нам нужно будет указать полный путь к файлу данных зоны, что для одной основной зоны не имеет большого значения.) Затем мы воспользуемся подключаемым модулем файла, чтобы настроить DNS-сервер в качестве основного для Zone и указать имя файла данных зоны, db.foo.example. Мы также будем использовать плагины ошибок и журнала, чтобы предупреждать нас о проблемах с загрузкой зоны и регистрировать запросы, которые мы получаем в foo.example, соответственно.

Некоторые DNS-серверы выполняют двойную функцию: авторитетные и рекурсивные DNS-серверы.

```
foo.example {
    root /etc/coredns/zones    
     # Don't forget to tell CoreDNS which directory to look in!
    file db.foo.example
    errors
    log
}

# Если вы хотите, чтобы ваш DNS-сервер также обрабатывал рекурсивные запросы,
# вам понадобится запись, подобная следующей.

. {
    forward 8.8.8.8 8.8.4.4
    cache
    errors
    log
}
```

## Secondary DNS Server

Вторичный DNS-сервер предоставляет авторитетные ответы на запросы в зонах, для которых он является авторитетным, но управление этими зонами осуществляется в другом месте (на другом DNS-сервере). Они полезны, поскольку предоставляют локальный источник ответов на запросы в дополнительных зонах, устраняя необходимость отправлять эти запросы на другой DNS-сервер.

Corefile для вторичного DNS-сервера аналогичен файлу для первичного DNS-сервера, но добавляет запись для вторичной зоны bar.example с необходимой передачей из поддирективы для указания IP-адреса главного DNS-сервера. На этот раз, поскольку мы собираемся неоднократно использовать плагины ошибок и журналов, мы определяем повторно используемый фрагмент под названием logerrors, который заменит их оба.

```
(logerrors) {
   errors
​   log
}

bar.example {
    transfer from 10.0.0.1
    import logerrors
}

# Данный DNS-сервер, конечно, может быть вторичным для некоторых зон
# и основной для остальных...

foo.example {
    file db.foo.example
    root /etc/coredns/zones
    import logerrors
}

# И снова, если вы хотите, чтобы ваш DNS-сервер обрабатывал рекурсивные
# запроса

. {
    forward 8.8.8.8 8.8.4.4
    cache
    import logerrors
}
```


# kubernetes

_kubernetes_ enables reading zone data from a Kubernetes cluster.

```
kubernetes [ZONES...]
```
Если указан только плагин, плагин kubernetes по умолчанию будет использовать зону, указанную в блоке сервера. Он будет обрабатывать все запросы в этой зоне и подключаться к кластеру Kubernetes. Он не будет предоставлять записи PTR для служб или записи A для модулей. Если используется ZONES, он определяет все зоны, для которых плагин должен быть авторитетным.

```
kubernetes [ZONES...] { 
	endpoint URL 
	tls CERT KEY CACERT 
	kubeconfig KUBECONFIG [CONTEXT] 
	namespaces NAMESPACE... 
	labels EXPRESSION 
	pods POD-MODE endpoint_pod_names 
	ttl TTL noendpoints 
	fallthrough [ZONES...] 
	ignore empty_service 
}
```


```
.:53 {
	errors
	health {
		lameduck 5s
	}
	ready
	log . { 
		class error
	}
	kubernetes cluster.local in-addr.arpa ip6.arpa {
		pods insecure
		fallthrough in-addr.arpa ip6.arpa
	}
	prometheus :9153
	forward . /etc/resolv.conf
	cache 30
	loop
	reload
	loadbalance
}
```

1. **.:53**: Это обозначает, что CoreDNS слушает на порту 53 (стандартный порт для DNS) для входящих DNS-запросов. Точка перед двоеточием означает, что сервер прослушивает все доступные сетевые интерфейсы.
    
2. **errors**: Плагин `errors` используется для ведения журнала ошибок.
    
3. **health**: Плагин `health` предоставляет информацию о состоянии здоровья CoreDNS. В данном случае, он включает опцию `lameduck 5s`, что означает, что после получения сигнала о завершении работы, CoreDNS будет ожидать 5 секунд, прежде чем завершить свою работу.
    
4. **ready**: Плагин `ready` предоставляет информацию о готовности CoreDNS обрабатывать запросы.
    
5. **log . { class error }**: Эта настройка указывает, что CoreDNS будет вести журнал только ошибок (класс "error").
    
6. **kubernetes cluster.local in-addr.arpa ip6.arpa**: Этот блок определяет настройки для интеграции с Kubernetes DNS. Он указывает на зоны, связанные с Kubernetes, такие как `cluster.local`, `in-addr.arpa` и `ip6.arpa`. Эти настройки позволяют CoreDNS разрешать имена Kubernetes-служб и обслуживать обратные DNS-записи для IP-адресов контейнеров.
    
7. **prometheus :9153**: Плагин `prometheus` запускает экспортер Prometheus для мониторинга CoreDNS на порту 9153.
    
8. **forward . /etc/resolv.conf**: Эта настройка указывает CoreDNS перенаправлять DNS-запросы на другой DNS-сервер, указанный в файле `/etc/resolv.conf`. Это может быть полезно, если CoreDNS не может разрешить запрос самостоятельно и должен передать его другому DNS-серверу для обработки.
    
9. **cache 30**: Плагин `cache` настраивается на кэширование DNS-запросов на 30 секунд. Это уменьшает нагрузку на DNS-сервер и ускоряет разрешение повторяющихся запросов.
    
10. **loop**: Плагин `loop` позволяет CoreDNS выполнять бесконечные циклы при разрешении DNS-имен.
    
11. **reload**: Плагин `reload` позволяет перезагружать конфигурацию CoreDNS без перезапуска сервера.
    
12. **loadbalance**: Плагин `loadbalance` выполняет балансировку нагрузки при разрешении DNS-имен, распределяя запросы между несколькими IP-адресами, если таковые имеются.

https://coredns.io/plugins/kubernetes/#syntax














# Domain Names and the Namespace

## DNS

Что такое днс
Базовые понятия
Характеристики, что такое рекурсивный днс
Какие протоколы и порты использует
Схема обменом сообщений
Стандартная запись
Виды записей

Общая информация

DNS (Domain Name System) - это система доменных имен, используемая в интернете и других сетях для преобразования человеко-читаемых доменных имен (например, [www.example.com](http://www.example.com/)) в IP-адреса и наоборот. DNS позволяет пользователям и компьютерам находить ресурсы в сети, используя удобные для запоминания доменные имена вместо числовых IP-адресов.

DNS использует два основных протокола:

1. **UDP (User Datagram Protocol)**: DNS обычно использует UDP для запросов и ответов. UDP - это протокол без установления соединения, что делает его быстрым и эффективным, но менее надежным в случае потери данных. Порт, который обычно используется для DNS, - это порт 53.
    
2. **TCP (Transmission Control Protocol)**: DNS также может использовать TCP для обмена данными в случаях, когда размер ответа DNS превышает размер, который может быть передан через UDP. Это обеспечивает надежную передачу данных, но менее эффективно по сравнению с UDP. Порт 53 также используется для DNS-запросов и ответов через TCP.
    

DNS работает на принципе клиент-сервер, где DNS-клиенты (резолверы) отправляют запросы DNS-серверам, чтобы получить информацию о доменных именах. DNS-серверы занимаются разрешением запросов и предоставляют ответы, содержащие соответствующие IP-адреса или другую информацию о доменных именах.

Порт 53 является стандартным портом для DNS, и он используется как для UDP, так и для TCP, взаимодействия между клиентами и серверами DNS.

  
Протокол DNS (Domain Name System) может использовать как UDP (User Datagram Protocol), так и TCP (Transmission Control Protocol), в зависимости от конкретных условий и требований:

1. **UDP (User Datagram Protocol)**:
    
    - UDP используется для большинства DNS-запросов и ответов.
    - Он предпочтителен для обычных DNS-транзакций, так как UDP - это протокол без установления соединения, и он более легковесен и быстр, чем TCP.
    - UDP используется, когда размер DNS-ответа помещается в стандартный UDP-пакет (обычно 512 байт или больше, если поддерживается EDNS).
    - Однако UDP имеет ограничение по размеру пакета, и если ответ DNS превышает это ограничение, то может использоваться TCP.
2. **TCP (Transmission Control Protocol)**:
    
    - TCP используется в случаях, когда размер ответа DNS превышает ограничение UDP, которое может возникнуть, например, при больших DNS-запросах или при использовании DNSSEC (DNS Security Extensions), что добавляет цифровую подпись к DNS-записям и увеличивает размер ответа.
    - TCP обеспечивает надежную передачу данных, что важно в случаях, когда целостность данных DNS является приоритетом.
    - Другими словами, если размер DNS-ответа превышает ограничение UDP, клиент и сервер переключаются на использование TCP для обмена данными.

В большинстве обычных сценариев и запросов DNS используется UDP, так как большинство DNS-запросов имеют небольшой размер ответа и могут быть обработаны без использования TCP. Однако при работе с большими и сложными DNS-запросами или при использовании расширений DNS, таких как DNSSEC, TCP может стать необходимым.

# DNS Servers
DNS-серверы выполняют две основные функции: отвечают на запросы о доменных именах и сами запрашивают информацию у других DNS-серверов о доменных именах.

DNS-серверы могут загружать данные зоны из файлов, называемых, как следует из названия, файлами данных зоны или, равнозначно, мастер-файлами. Каждый файл данных зоны содержит полное описание зоны: все записи, привязанные к доменным именам в этой зоне. DNS-сервер, который загружает информацию о зоне из файла данных зоны, называется первичным DNS-сервером для этой зоны.

# Resolvers
Резолверы (DNS-клиенты) принимают запросы приложений о получении информации о доменном имени и преобразуют их в DNS-запросы. Затем они отправляют эти запросы DNS-серверам и ожидают ответов. Если резолвер не получает ответ на конкретный запрос в разумное время (обычно в течение одной или нескольких секунд), он может повторно отправить запрос на тот же DNS-сервер или попробовать обратиться к другому DNS-серверу. Когда резолвер получает ответ, он распаковывает его в структуру данных и передает ее обратно в приложение. Некоторые резолверы выполняют дополнительные действия, включая кэширование недавно полученных ответов.


## Формат пакета DNS

![[Pasted image 20230911170059.png]]
### Типы служб DNS

**Авторитативный DNS-сервис.** **Авторитативный DNS-сервис** предоставляет механизм обновления, используемый разработчиками для управления публичными именами DNS. Она отвечает на запросы к DNS, преобразуя доменные имена в IP‑адреса, чтобы обеспечить взаимодействие компьютеров между собой. Авторитативный DNS-сервис полностью отвечает за домен и предоставляет информацию об IP-адресах в ответ на запросы **рекурсивных DNS-серверов**. **Amazon Route 53 является авторитативным DNS-сервисом.**

**Рекурсивный DNS-сервис.** Обычно клиенты не отправляют запросы напрямую к авторитативным DNS-сервисам. Вместо этого они взаимодействуют с другим DNS-сервисом, который называется **преобразователь имен** или **рекурсивный DNS-сервис**. Рекурсивный DNS-сервис похож на управляющего в отеле: сам он не хранит записи DNS, но действует в качестве посредника, который может достать нужную информацию для вас. Если рекурсивный DNS-сервис хранит информацию в **кэше** или постоянном хранилище в течение определенного времени, тогда он отвечает на DNS-запрос, возвращая информацию об источнике или IP-адрес. Если он не хранит эту информацию, он передает запрос в один или несколько авторитативных DNS-серверов.

## Zone

Зона (zone) - это домен минус поддомены, которые были делегированы в другие места. Однако, если внутри домена не производится делегации, в таком случае домен и зона содержат одни и те же узлы. Например, если ниже домена cs.berkeley.edu не происходит дополнительной делегации, то домен cs.berkeley.edu и зона cs.berkeley.edu фактически остаются одним и тем же.

DNS-серверы также могут загружать данные зоны из других DNS-серверов с помощью механизма, называемого передачей зоны (zone transfer). DNS-сервер, который загружает информацию о зоне из другого DNS-сервера с использованием передачи зоны, называется вторичным DNS-сервером для этой зоны. DNS-сервер, с которого вторичный DNS-сервер передает зону, называется его мастер DNS-сервером.

После передачи зоны, вторичный DNS-сервер может сохранить копию данных зоны на диске, иногда в так называемом резервном файле данных зоны (backup zone data file). Когда вторичный DNS-сервер периодически передает новую версию зоны от своего мастер DNS-сервера, он обновляет данные на диске. Резервные данные полезны, если вторичный DNS-сервер должен перезапуститься, потому что он может сначала загрузить резервные данные, а затем проверить, актуальны ли они по сравнению с версией зоны на мастер DNS-сервере. Если данные актуальны, передача зоны не требуется. И если мастер DNS-сервер недоступен, у вторичного DNS-сервера все равно есть данные зоны, на которые он может отвечать.

![[Pasted image 20230911165706.png]]

  
Оба первичный и вторичный DNS-серверы для зоны считаются авторитетными для этой зоны. Это означает, что они могут однозначно отвечать на любой запрос о доменном имени в этой зоне.  Один DNS-сервер может быть авторитетным для множества зон одновременно и может быть первичным для одних и вторичным для других. 


# Resolution and Recursion

Разрешение (resolution) - это процесс, в котором резолверы и DNS-серверы сотрудничают для поиска ответов (в форме ресурсных записей), хранящихся в распределенной базе данных DNS. Иногда разрешение бывает простым: резолвер отправляет запрос DNS-серверу от имени приложения, и DNS-сервер является авторитетным для зоны, которая содержит доменное имя в запросе, поэтому он напрямую отвечает резолверу с записями, составляющими ответ. Однако в случаях, когда DNS-сервер не является авторитетным для зоны, содержащей ответ, процесс разрешения более сложный.

По умолчанию процесс разрешения происходит сверху вниз в пространстве имен DNS. Напомним, что пространство имен представляет собой инвертированное дерево: начиная с вершины инвертированного дерева, можно дойти до любого узла. И доменное имя в запросе указывает DNS-серверу, по какой "ветви" следовать от каждого узла, как показано в тексте.

![[Pasted image 20230911170648.png]]

DNS-сервер может начать процесс разрешения, отправив запрос любому из корневых DNS-серверов. Вероятно, корневой DNS-сервер не будет авторитетным для зоны, содержащей доменное имя в запросе, но он, по крайней мере, знает DNS-серверы, авторитетные для верхнего уровня зоны (например, com, net), под которой находится это доменное имя. Корневой DNS-сервер вернет список DNS-серверов, авторитетных для соответствующей верхней зоны, в виде референса (referral) для запрашивающего DNS-сервера. Референс также содержит NS-записи для верхней зоны.

DNS-сервер продолжает запрос, обращаясь к одному из DNS-серверов верхней зоны, следуя референсам, пока он не достигнет DNS-серверов, авторитетных для доменного имени в запросе. Когда он обращается к одному из этих DNS-серверов, он должен получить ответ, а не референс, как показано на рисунке.

![[Pasted image 20230911170741.png]]

Процесс, который первый DNS-сервер выполняет, начиная с корневых DNS-серверов и следуя референсам до получения ответа, называется рекурсией (recursion). 



```
[NAME] [TTL] [CLASS] TYPE RDATA
```

```
@             3600  IN  A  10.0.0.1  # TTL 3600 секунд или 1 час
              1h    IN  A  10.0.0.2  # То же самое
www           1h30m IN  A  10.0.0.3  # TTL 1 час 30 минут или 90 минут
                    IN  A  10.0.0.4  # TTL из предыдущей записи, то есть 90 минут.
```
## Name
Поле NAME содержит доменное имя, к которому прикреплена эта ресурсная запись. Это может быть полностью квалифицированным доменным именем (FQDN), заканчивающимся точкой, или относительным доменным именем, которое не заканчивается точкой. Относительные доменные имена интерпретируются как заканчивающиеся текущим исходным значением (origin), которое по умолчанию является доменным именем зоны, описываемой файлом данных зоны. Это удобно, потому что при написании файла данных зоны для, например, foo.example, вы не захотели бы каждый раз вводить "foo.example" в конце каждого имени.

Если вы хотите обратиться к самому исходному значению (origin), а не иметь его добавленным к введенному имени, вы используете символ "@" в поле NAME, без завершающей точки. Вы также можете использовать одиночную точку ("."), чтобы обратиться к корню, хотя обычно вы бы не использовали это в поле NAME ресурсной записи, если бы не редактировали файл данных корневой зоны или файл подсказок для корня.

Как видно из формата, который мы показали вам недавно, поле NAME является необязательным. Если поле NAME опущено, строка должна начинаться с пробелов, и ресурсная запись, указанная в строке, прикрепляется к самому недавно указанному доменному имени.

## TTL
  
Поле TTL (Time to Live) определяет значение времени жизни ресурсной записи, которое регулирует, как долго рекурсивный DNS-сервер может кэшировать эту запись. TTL изначально (то есть на уровне данных, передаваемых по сети) представляет собой 32-битное целое число секунд, и вы можете указывать TTL в таком формате. Однако теперь также существуют масштабные факторы, такие как "s" для секунд, "m" для минут, "h" для часов, "d" для дней и "w" для недель, например, "1d", "30m" или "1h30m". Это позволяет избежать необходимости запоминать, скажем, "В сутках 86400 секунд".

## CLASS

Как упоминалось ранее в этой главе, поле CLASS почти всегда устанавливается в IN, что означает Internet, поэтому неудивительно, что IN является значением по умолчанию. Существуют и другие классы, такие как CH для ChaosNet и HS для Hesiod, но их использование крайне редко, потому что функции, которые предназначались для обслуживания этих других классов, никогда не получили широкого распространения.

# Resource Record Types

1. **A (IPv4 address)**:
    - Сопоставляет доменное имя с одним IPv4-адресом.
    - Используется для разрешения доменных имен в IPv4-адреса.
2. **AAAA (IPv6 address)**:
    - Сопоставляет доменное имя с одним IPv6-адресом.
    - Используется для разрешения доменных имен в IPv6-адреса.
3. **CNAME (alias)**:
    - Сопоставляет доменное имя (псевдоним) с другим доменным именем (каноническим именем).
    - Используется для создания алиасов или перенаправлений на другие доменные имена.
4. **MX (mail exchanger)**:
    - Указывает на почтовый обменник (почтовый сервер) для адресата электронной почты.
    - Помогает маршрутизировать почту к правильному почтовому серверу.
5. **NS (name server)**:
    - Указывает на DNS-сервер (или имя сервера) для конкретной зоны.
    - Используется для определения авторитетных DNS-серверов для данной зоны.
6. **PTR (pointer)**:
    - Сопоставляет IP-адрес обратно в доменное имя.
    - Используется для выполнения обратного DNS-разрешения.
7. **SOA (start of authority)**:
    - Предоставляет параметры и информацию о зоне, такие как имя владельца зоны, адрес электронной почты владельца, номер версии и другие параметры.
    - Используется для определения авторитета для данной зоны.
